#include <iostream>
/* Περιέχει τα αντικείμενα εισόδου εξόδου */
using namespace std;
/* Το iostream έχει μία ομάδα ονομάτων std
και για να καλέσουμε κάτι απο εκεί θα πρέπει να
χρησιμοποιούμε τον τελεστή εμβέλειας ::
π.χ.: std::cout<<... 
Χρησιμοποιώντας using namespace std;
μπορούμε να χρησιμοποιούμε όλες τις συναρτήσεις με πρόθεμα std
χωρίς το std π.χ.: cout<<... ή
Χρησιμοποιώντας using std::cout;
μπορούμε να χρησιμοποιούμε μόνο το cout */



/* Δοκιμαστική Κλάση για να εξηγήσουμε κάποιο θέμα αρζικοποίησης στον κατασκευαστή */
class member{
    int x;
    public:
        member(int in_x){
            x = in_x;
        };
        ~member(){
            // no need for destructor
        };
};
/* Δοκιμαστική Κλάση για να εξηγήσουμε κάποιο θέμα αρζικοποίησης στον κατασκευαστή */



class STRING{
    /* Όλα τα μέλη της κλάσης είναι ιδιωτικά εκτός αν δηλωθούν ως public */
    int n;
    char *str;
    
    /* Έστω ότι θέλουμε η κλάση μας να έχει και ένα αντικείμενο τύπου member. Αυτό το αντικείμενο θα πρέπει να αρχικοποιηθεί.
    Σε περίπτωση που το αντικείμενο έχει default constructor, θα αρχικοποιηθεί απλά με τη δήλωσή του. Στη δικία μας περίπτωση όμως
    που το αντικείμενο δεν έχει default constructor θα πρέπει η αρχικοποίησή του να γίνει κατά την κλήση του constructor της κλάσης
    που το περιέχει (σε όλους τους constructor αλλιώς θα έχουμε πρόβλημα), πρίν τον κύριο κώδικα. πχ: δες παρακάτω. */
    
    member m; // Το αντικείμενο δεν έχει default constructor και πρέπει να αρχικοποιηθεί, δες κώδικα του constructor της STRING.
    
    public:
        /* Κάθε κλάση θα πρέπει να έχει: 
        α) έναν default κατασκευαστή (χωρίς να παίρνει ορίσματα)
        β) έναν ή περισσότερους κατασκευαστές [Υπερφόρτωση συναρτήσεων (ανάλογα με τα ορίσματα θα επιλέγει κατάλληλα ο μεταφραστής)]
        γ) έναν ή περισσότερους κατασκευαστές αντιγράφων (για να μπορεί να αρχικοποιείται με όρισμα ήδη υπάρχον αντικείμενο)
        δ) έναν καταστροφέα
        ε) getters και setters για να μπορούμε να έχουμε πρόσβαση στα ιδιωτικά μέλη της κλάσης */
        
        // default κατασκευαστής
        STRING(/* int val */); /* Το int val θα χρησιμοποιηθεί σε περίπτωση που θέλουμενα δώσουμε κάθε φορά διαφορετική τιμή στο 
                               αντικείμενο m κατά την κατασκευή του αντικειμένου STRING. */
        
        // κατασκευαστές με ορίσματα
        STRING(char *in_str); // για ορίσματα συμβολοσειρών
        STRING(const char *in_str); // για ορίσματα που δίνονται απο το πληκτρολόγιο και αποθηκεύονται σαν const char*
        
        // κατασκευαστής αντιγράφου
        STRING(const STRING &obj); 
        /* το &obj σημαίνει ότι το όρισμα που θα δοθεί θα δημιοιυργήσει μία αναφορά στο αρχικό όρισμα
        θα χρησιμοποιηθεί σαν να είναι το ίδιο το αντικείμενο, σαν να χρησιμοποιούμε pointer αλλα μας δίνει 
        μεγαλύτερη ευχέρια στο πέρασμα τιμών by referece. Το αντικείμενο χρησιμοποιείται με το όνομά του 
        κανονικά με΄σα στο σώμα της συνάρτησης. */
        /* το const χρησιμοποιείται έτσι ώστε παρόλο που η αναφορά μας δείχνει στο κανονικό αντικέιμενο
        και δεν είναι απλά ένα αντίγραφο, να μην μπορεί να αλλειώθεί το αντικείμενο μέσο της αναφοράς.
        Είναι σαν το const type *pointer, το pointer δείχνει στο πραγματικό αντικείμενο αλλα δεν μπορούν να γίνουν αλλαγές */
        
        // καταστροφέας
        ~STRING();
        
        // getters
        int get_n() const;
        char* get_string() const;
        /* το const χρησιμοποιείται πάντα στο τέλος μίας συνάρτησης οι οποία απλά θα επιστρέφει κάτι
        και δε θέλουμε να αλλειώσει καταλάθος τα ορίσματα που τις παρέχονται */
        
        // setters
        void set_string(char *in_str);
        void set_string(const char *in_str);
        
        /* Μία κλάση μπορεί να υπερφορτώσει τους τελεστές που ενεργούν πάνω στα ατνικείμενά της.
        Όλα τα παρακάτω δουλεύουν σαν μέθοδοι κλάσης π.χ.: obj.operator(type variable);
        Άρα αριστερά απο τον τελεστή θα πρέπει να έχουμε αντικείμενο και δεξιά ότι ορίσαμε στην παρένθεση
        Επίσης όταν θέλουμε αλυσιδωτές πράξεις όπως στο = θα πρέπει να επιστρέφεται αναφορά στο ίδιο το αντικείμενο
        και όχι σε κάποιο αντίγραφο, διότι το αντικείμενο υπάρχει και μπορούν να γίνουν επιμέρους πράξεις πάνω σε αυτό
        ενώ το αντίγραφο θα πρέπει να αποθηκευτεί κάπου μετά την κλήση της μεθόδου για να μπορεί να χρησιμοποιηθεί.
        π.χ.: το b = a++ είναι σωστό γιατί το a++ θα αποθηκευτεί στο b
        ενώ a++ = b είναι σαν να λέμε 5 = b (να θυμάσαι ότι το variable++ είναι μέθοδος. */
        STRING &operator=(const char *right);
        STRING &operator=(const STRING &right);
        
        // Προσθήκη χαρακτήρα στο τέλος του String
        STRING &operator+=(char right);
        
        /* Πάντα θα πρέπει να θυμόμαστε ότι στον τύπο της συνάρτησης βάζουμε αυτό που θέλουμε να επιστρέφει
        πχ.: παρακάτω, προφανώς το άθροισμα 2 αντικειμένων θέλουμε να είναι ένα καινούριο αντικείμενο και
        τα παλιά αντικείμενα δεν θα πρέπει να υφίστανται αλλαγές. */
        STRING operator+(const STRING &right);
        
        bool operator<(const STRING &right);
        bool operator>(const STRING &right);
        bool operator==(const STRING &right);
        
        char &operator[](int i);
        
        /* Όλες οι φιλικές συναρτήσεις ουσιαστικά δηλώνουν ότι το ατνικείμενό μας εμπιστέβεται
        τις συναρτήσεις ή τις κλάσεις αυτές και τους δίνει πρόσβαση στα ιδιωτικά μέλη του.
        Για κλάση θα γάφαμε friend class class_name;
        Στις παρακάτω συναρτήσεις ουσιαστικά το ατνικείμενό δίνει πρόσβαση στα ιδιωτικά του μέλη
        και έτσι υπερφορτώνωνται τελεστές που υπενεργούν έξω απο το αντικείμενο, όχι σαν μέθοδοι.
        Εδώ δηλαδή για τους τελεστές αυτούς ορίζουμε επ' ακριβώς τι θα μπεί στο δεξί και τι στο αριστερό μέρος του τελεστή. */
        friend ostream &operator<<(ostream &left, const STRING &right);
        friend istream &operator>>(istream &left, STRING &right);
        
        // SOS!!! Ότι στατικό υπάρχει καλείται εκτός κλάσης με το όνομα της κλάσης και το δείκτη εμβάλειας::.
        
        /* Οι στατικές μεταβλητές θα πρέπει:
        1) να είναι πάντα δημόσιες και αποθηκεύονται ξεχωριστά απο την κλάση.
        2) να μοιράζονται απο κοινού σε όλα τα αντικείμενα της κλάσης και όλα τα αντικείμενα έχουν πρόσβαση σε αυτές.
        3) Μία αλλαγή απο ένα αντικείμενο θα φανεί σε όλα τα ατνικείμενα για την κάθε στατική μεταβλητή.
        4) Πάντα θα πρέπει να αρχικοποιείται στο σώμα τις κλάσης, πρίν απο τη main δηλαδή */
        
        // Μία στατική μεταβλητή θα μπορεί για παράδειγμα να μας δίχνει το μέγιστο περιεχόμενο κάθε συμβολοσειράς.
        static int max_length;
        
        /* Οι στατικές μέθοδοι: 
        1) ανήκουν στην κλάση
        2) δεν έχουν πρόσβαση σε μη στατικές μεταβλητές της κλάσης και ούτε και στον δείκτη this
        3) μπορούν να διαχειριστούν στατικές μεταβλητές
        4) μπορούν να χρησιμοποιηθούν και χωρίς να δημιουργηθεί κάποιο αντικείμενο */
        
        int static get_max_length();
};